"use strict";import{VERSION}from"../env/data.js";import AxiosError from"../core/AxiosError.js";const validators={};["object","boolean","number","function","string","symbol"].forEach((type,i)=>{validators[type]=function validator(thing){return typeof thing===type||"a"+(i<1?"n ":" ")+type}});const deprecatedWarnings={};validators.transitional=function transitional(validator,version,message){function formatMessage(opt,desc){return"[Axios v"+VERSION+"] Transitional option '"+opt+"'"+desc+(message?". "+message:"")}return(value,opt,opts)=>{if(validator===false){throw new AxiosError(formatMessage(opt," has been removed"+(version?" in "+version:"")),AxiosError.ERR_DEPRECATED)}if(version&&!deprecatedWarnings[opt]){deprecatedWarnings[opt]=true;console.warn(formatMessage(opt," has been deprecated since v"+version+" and will be removed in the near future"))}return validator?validator(value,opt,opts):true}};function assertOptions(options,schema,allowUnknown){if(typeof options!=="object"){throw new AxiosError("options must be an object",AxiosError.ERR_BAD_OPTION_VALUE)}const keys=Object.keys(options);let i=keys.length;while(i-- >0){const opt=keys[i];const validator=schema[opt];if(validator){const value=options[opt];const result=value===undefined||validator(value,opt,options);if(result!==true){throw new AxiosError("option "+opt+" must be "+result,AxiosError.ERR_BAD_OPTION_VALUE)}continue}if(allowUnknown!==true){throw new AxiosError("Unknown option "+opt,AxiosError.ERR_BAD_OPTION)}}}export default{assertOptions:assertOptions,validators:validators};